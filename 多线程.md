# 多线程

## 1.线程概述

### 1.1 线程的相关概念

- 进程

  > 进程(Process)是计算机中的程序关于某数据集合的一次运行活动，是操作系统进行资源分配与调度的基本单位。
  >
  > 可以把线程简单的理解为正在操作系统中运行的一个程序。

- 线程

  > 线程(thread)是进程的一个执行单位，也被成为轻量级进程，不拥有资源，使用所属线程分配的资源，线程上下文切换速度快。
  >
  > 进程是线程的容器，一个进程至少有一个线程，一个线程可以有多个进程。

- 主线程与子线程

  > JVM启动时会创建一个主线程，该线程负责执行main方法，主线程就是运行main方法的线程。
  >
  > Java中的线程不孤立,线程之间存在一些联系.如果在A线程中创建了B线程,称B线程为A线程的子线程,相应的A线程就是B线程的父线程。

## 1.2 线程的创建与启动

线程创建的常用方式:

1. 继承Tread类,重写run方法，使用start()启动

   ```java
   class MyThread extends Thread{
       @Override
       public void run(){
           System.out.println("MyThread: "+new Date());
           try {
               Thread.sleep(5000);
           } catch (InterruptedException e) {
               e.printStackTrace();
           }
       }
   }
    new MyThread().start();
   ```

   

2. 实现Runnable接口,重现run方法，使用new Thread(Runnable ...).start()启动

   ```java
   class MyRunnable implements Runnable{
       @Override
       public void run() {
           System.out.println("MyRunnable:" + new Date());
           try {
               Thread.sleep(5000);
           } catch (InterruptedException e) {
               e.printStackTrace();
           }
       }
   }
   new Thread(new MyRunnable()).start();
   ```

   

3. 使用Callable和Future创建线程

4. 使用线程池创建对象(例如ThreadPoolExecutor)

   ```java
   /**
    *  任务队列:
    *  1.直接提交队列
    *      SynchronousQueue<>(): 提交的任务不会被保存，总是会马上提交执行。如果用于执行任务的线程数量小于maximumPoolSize，
    *      则尝试创建新的进程，如果达到maximumPoolSize设置的最大值，则根据你设置的handler执行拒绝策略。因此这种方式你提交的任务不会被缓存起来，
    *      而是会被马上执行
    *  2.有界队列
    *      ArrayBlockingQueue<>(): 使用ArrayBlockingQueue有界任务队列，若有新的任务需要执行时，线程池会创建新的线程，
    *      直到创建的线程数量达到corePoolSize时，则会将新的任务加入到等待队列中。若等待队列已满，即超过ArrayBlockingQueue初始化的容量，
    *      则继续创建线程，直到线程数量达到maximumPoolSize设置的最大线程数量，若大于maximumPoolSize，则执行拒绝策略。
    *  3.无界队列
    *      LinkedBlockingQueue<>(): 使用无界任务队列，线程池的任务队列可以无限制的添加新的任务，
    *      而线程池创建的最大线程数量就是你corePoolSize设置的数量，也就是说在这种情况下maximumPoolSize这个参数是无效的，
    *      哪怕你的任务队列中缓存了很多未执行的任务，当线程池的线程数达到corePoolSize后，就不会再增加了；若后续有新的任务加入，
    *      则直接进入队列等待
    *  4.优先队列
    *      PriorityBlockingQueue它其实是一个特殊的无界队列，它其中无论添加了多少个任务，线程池创建的线程数也不会超过corePoolSize的数量，
    *      只不过其他队列一般是按照先进先出的规则处理任务，而PriorityBlockingQueue队列可以自定义规则根据任务的优先级顺序先后执行。
    */
       ThreadPoolExecutor executor = new ThreadPoolExecutor(1, 2, 1, TimeUnit.SECONDS, new ArrayBlockingQueue<>(2), 				                                                     Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy());
       for(int i = 0; i < 5; i++) {
           executor.execute(new ExecutorRunnable());
       }
   ```

   

## 1.3 多线程常用方法

#### 1.3.1 currentThread():获取当前线程

```java
class SubThread1 extends Thread{
    public SubThread1(){
        System.out.println("construct: " + Thread.currentThread().getName());
    }
    @Override
    public void run(){
        System.out.println("run: " + Thread.currentThread().getName());
    }
}
public class Test01CurrentThread {
    public static void main(String[] args) {
        System.out.println("main: "+Thread.currentThread().getName());
        SubThread1 subThread1 = new SubThread1();
        subThread1.start();
    }
}
/**
 * main: main
 * construct: main
 * run: Thread-0
 */
```

#### 1.3.2 setName()/getName()

- thread.setName(线程名称):设置线程名称
- thread.getName():返回线程名称

通过设置线程名称,有助于程序调试,提高程序的可读性,建议为每个线程都设置一个能够体现线程功能的名称

#### 1.3.3 isAlive()

- thread.isAlive()判断当前线程是否处于活动状态

  活动状态就是线程已启动并且尚未终止

  ```java
  public class Test {
      public static void main(String[] args) {
          SubThread subThread = new SubThread();
          System.out.println("begin==" + subThread.isAlive()); // 在线程启动前 false
          subThread.start();
          for (int i = 0; i < 50; i++) {
              System.out.println("end==" + subThread.isAlive()); // 线程启动后为true, 线程结束后为false
          }
      }
  }
  ```

#### 1.3.4 sleep(miles)

- Thread.sleep(miles):当前线程休眠miles毫秒

  当前线程指Thread.currentThread()返回的线程

#### 1.3.5 getId()

- Thread.currentThread().getId()获取当前线程id

#### 1.3.6 yield()

- Thread.yield()

  Thread.yield()方法的作用是放弃当前的CPU资源

  ```java
  public class Test {
      public static void main(String[] args) {
          // 开启子线程,计算累加和
          SubThread t = new SubThread();
          t.start();
  
          // 在main()方法中计算累计和
          long begin = System.currentTimeMillis();
          long sum = 0;
          for (int i = 0; i < 10000000; i++) {
              sum+=i;
          }
          long end = System.currentTimeMillis();
          System.out.println("main方法,用时: " + (end - begin));
      }
  }
  public class SubThread extends Thread{
      @Override
      public void run() {
          long begin = System.currentTimeMillis();
          long sum = 0;
          for (int i = 0; i < 10000000; i++) {
              sum+=i;
              Thread.yield();
          }
          long end = System.currentTimeMillis();
          System.out.println("用时: " + (end - begin));
      }
  }
  
  ```

1.3.7 setPriority()

- thread.setPriority(num); 设置线程优先级

  java线程的优先级取值范围1~10,如果超出这个范围会抛出异常IllgalArgumentException.

在操作系统中,优先级较高的线程获得CPU的资源越多

线程优先级本质上只是给线程调度器一个提示信息,以便于调度器决定先调度哪些线程.**注意不能保证优先级高的线程先运行.**

Java优先级设置不当或者滥用可能会导致某些线程永远无法得到运行

