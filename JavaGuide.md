[TOC]

# 三、计算机网络面试题

## 3.1 计算机网络

### 3.1.1 OSI与TCP/IP各层的结构和功能

1.OSI结构体系7层

​    应用层->表示层->会话层->运输层->网络层->数据链路层->物理层

2.TCP/IP的体系结构

​    应用层->运输层->网际层->网络接口层

3.五层协议

​    应用层->运输层->网络层->数据链路层->物理层

#### 应用层

应用层的任务是通过应用进程间的交互来完成特定网络应用。

DNS HTTP SMTP POP3

#### 运输层

运输层的主要任务就是负责向两台主机进程之间的通信提供通用的数据传送服务。

运输层的两种主要协议：

1. TCP(Transmission Control Protocol) -- 提供**面向连接**的，**可靠的**数据传输服务
2. UDP(User Datagram Protocol)--提供**无连接**的，尽最大努力的数据传输服务（不保证数据传输的可靠性）

#### 网络层

在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点，确保数据及时传送。

#### 数据链路层

两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。数据链路层将网络层交下来的IP数据包组成帧。

#### 物理层

实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。

!['OSI7层结构体系'](http://image.xybh.online/OSI.png)

### 3.1.2 TCP三次握手和四次挥手

为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。

#### TCP三次握手流程

![三次握手](http://image.xybh.online/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png)

- 客户端-发送带有SYN标志的数据包-服务端 （一次握手）

- 服务端-发送带有SYN/ACK标志的数据包-客户端（二次握手）

  客户端-发送带有ACK标志的数据包-服务端（三次握手）

- 

#### 为什么要三次握手

三次握手的目的是为了建立可靠的通信信道。三次握手最主要的目的就是双方确认自己与对方的发送和接受是正常的。

```
第一次握手：Client什么都无法确认；Server可确认对方发送正常，自己接收正常。
第二次握手：Client可确认自己发送、接收正常，对方发送、接收正常；Server确认对方发送正常，自己接收正常(无法根据这次握手，增加判断)。
第三次握手：Client确认自己发送、接收正常，对方发送、接收正常；Server可确认对方发送、接收正常，自己发送、接收正常。
```

#### 为什么第二次握手要传回SYN

接收端传回发送端所发送端SYN是为了告诉发送端，我接受到的信息确实就是你所发送的信号。

#### 为什么传了SYN，还要传ACK

双方通信无误必须两者互相发送信息都无误。传了SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要ACK信号来进行验证。

#### 四次挥手

![四次挥手](http://image.xybh.online/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png)

断开一个TCP连接则需要“四次挥手”

- 客户端-发送一个FIN-服务端，用于关闭客户端到服务器的数据传送（第一次挥手）
- 服务端-收到FIN，发送一个ACK，确认序号为收到序号+1。
- 服务端-发送一个FIN-客户端，用于关闭与客户端的连接
- 客户端-发回ACK报文确认，并将确认序号设置为收到序号+1

#### 为什么要四次挥手

任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。

### 3.1.2 TCP,UDP协议的区别

![image-20210106161735912](http://image.xybh.online/image-20210106161735912.png)

UDP传送数据之前不需要建立连接，提供一个无连接的数据传输服务，远程主机在收到UDP报文后，不需要给出任何确认。传输效率高，虽然不提供可靠交互，但在某些情况下UDP确是一种最有效的工作方式（一般用于即时通信），比如QQ语音、QQ视频、直播等。

```
为什么UDP不可靠，还要应用于即时通信呢？
   UDP不可靠但是效率高，传输开销小，无连接不会持续占用服务器的连接资源，适用于实时数据的传输，即使偶尔丢失一两个数据包，也不会对接受结果产生太大影响。
```

TCP提供面向连接的服务。在传送数据之前必须建立连接，数据传送结束后要释放连接。TCP不提供广播或者多播服务。由于TCP提供可靠的、面向连接的传输服务，难以避免的增加了许多开销，如确认、流量控制、计时器以及连接管理。这不仅使协议数据单元的首部增大很多，还要占用许多的处理机资源。TCP一般用于文件传输、发送和接受邮件、远程登录等场景。

### 3.1.3 TCP 协议如何保证可靠传输

应用数据被分割成TCP认为最适合发送的数据块

TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。

**校验和：**TCP将保持它首部和数据的校验和。这是一个端对端的校验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个保温段和不确认收到此报文段。

TCP的接收端会丢弃重复的数据。

**流量控制：**TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量协议是可变大小的滑动窗口协议。

**拥塞控制：**当网络拥塞时，减少数据的发送。

**ARQ协议：**也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。

**超时重传：**当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

### 3.1.4 ARQ协议

**自动重传请求**（Automatic Repeat-reQuest, ARQ)是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的数据传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议。

#### 停止等待ARQ协议

- 停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到ACK确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；
- 在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认；

优点：简单

缺点：信道利用率低，等待时间长



### 3.1.5 在浏览器中输入Url地址->显示主页的过程

1. DNS解析
2. TCP连接
3. 发送HTTP请求
4. 服务器处理请求并返回HTTP报文
5. 浏览器解析页面
6. 连接结束

### 3.1.6 状态码

|      |                                |                            |
| ---- | ------------------------------ | -------------------------- |
|      | 类别                           | 原因短语                   |
| 1XX  | Informational(信息性状态码)    | 接受的请求正在处理         |
| 2XX  | Success(成功状态码)            | 请求正常处理完毕           |
| 3XX  | Redirection(重定向状态码)      | 需要进行附加操作以完成请求 |
| 4XX  | Client Error(客户端错误状态码) | 服务器无法处理请求         |
| 5XX  | Server Error(服务器错误状态吗) | 服务器处理请求错误         |

常见的HTTP状态码

200：表示从客户端发来的请求在服务器端被正常处理了

204(No Content):代表服务器接收的请求已被成功处理，但在返回的响应报文中不含该实体的主体部分。

206(Partial Content)：代表客户端进行了范围请求，而服务器成功执行了这部分的GET请求。

301(Moved Permanently)：永久性重定向。该状态码表示请求的资源已被分配到新的URI，以后应使用资源现在所指的URI。

302(Found)：临时重定向。该状态码表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问。

303(See Other)：表示由于请求对应的资源存在另一个URI，应使用GET方法定向获取请求的资源。

304(Not Modified)：表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回304。

400(Bad Request)：表示请求报文中存在语法错误。

401(Unauthorized):表示发送的请求需要有通过HTTP认证的信息。另外若之前进行过1次请求，则表示用户认证失败。

403(Forbidden):表明对请求资源的访问被服务器拒绝了。

404(Not Found):表明服务器上无法找到请求的资源。

500(Internal Server Error):表明服务器端在执行请求时发生了错误。

503(Service Unavailable):表明服务器暂时处于超负载或者正在进行停机维护。

### 3.1.7 HTTP长连接，短连接

在HTTP/1.0中默认使⽤短连接。也就是说，客户端和服务器每进⾏⼀次HTTP操作，就建⽴⼀次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web⻚中包含有其他的Web资源（如JavaScript⽂件、图像⽂件、CSS⽂件等），每遇到这样⼀个Web资源，浏览器就会重新建⽴⼀个HTTP会话。
⽽从HTTP/1.1起，默认使⽤⻓连接，⽤以保持连接特性。使⽤⻓连接的HTTP协议，会在响应头加⼊这⾏
代码：

```
Connection:keep-alive
```

在使⽤⻓连接的情况下，当⼀个⽹⻚打开完成后，客户端和服务器之间⽤于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使⽤这⼀条已经建⽴的连接。Keep-Alive不会永久保持连接，它有⼀个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现⻓连接需要客户端和服务端都⽀持⻓连接。

### 3.1.8 HTTP是不保存状态的协议，如何保存用户状态？

HTTP是一种不保存状态，即无状态(stateless)协议。使用Session来通过服务端记录用户的状态。

### 3.1.9 Cookie的作用是什么？和Session有什么区别？

Cookie和Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。

**Cookie一般用来在客户端保存用户信息**

**Session一般用来在服务端记录用户状态**



### 3.1.10 URI和URL的区别是什么？

URI是统一资源标识符，可以唯一标识一个资源。

URL是同一资源定位器，可以提供该资源的路径。



### 3.1.11 HTTP和HTTPS的区别？

端口：HTTP使用80端口 HTTPS使用443端口

安全性：HTTP使用明文传输 HTTPS基于SSL/TLS进行加密传输

资源消耗：因为HTTPS要进行加密解密等操作，所以HTTPS比HTTP耗费更多的服务器资源。



# 四、数据库面试题总结

## 4.1 MySQL

### 4.1.1 什么是MySQL？

MySQL是一种关系型数据库，在Java企业级开发中非常常用，因为MySQL是开源免费的，并且方便拓展。MySQL的默认端口号是3306。

### 4.1.2 MyISAM和InnoDB的区别

MyISAM是MySQL的默认数据库引擎（5.5版本之前）。虽然性能极佳，而且提供的大量的特性。但是MyISAM不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。

InnoDB（5.5版本后引入，事务性数据库引擎），5.5版本后默认存储引擎为InnoDB。

**二者的对比：**

**是否支持行级锁： ** MyISAM只有表级锁，而InnoDB支持行级锁和表级锁，默认为行级锁。

**是否支持事务和崩溃后的安全恢复： **MyISAM强调的是性能，每次查询具有原子性，其执行速度快，但是不提供事务支持。InnoDB提供事务支持，外键等高级数据库功能。具有事务、回滚和崩溃修复能力的事务安全型表。

**是否支持外键： **MyISAM不支持，InnoDB支持。

**是否支持MVCC：** 仅InnoDB支持。应对高并发事务，MVCC比单纯的加锁更高效；MVCC只在`READ COMMITTED`和`REPEATABLE READ`两个隔离级别下工作；MVCC可以使用乐观锁和悲观锁来实现。

```
不要轻信“MyISAM比InnoDB快”之类的经验之谈，这个结论往往不是绝对的。在很多我们已知场景中，InnoDB的速度都可以比MyISAM快，尤其是用到了聚簇索引，或者需要访问的数据可以放进内存的应用。
```

### 4.1.3 索引

MySQL的索引主要有BTree索引和哈希索引。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其他场景大部分使用BTree索引。

MySQL的BTree索引使用的是B树中的B+Tree，两种引擎对其实现并不相同。

**MyISAM：** B+Tree叶节点的data域存放的是数据记录的地址。首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，再根据data域的值去查找对应的数据记录。这被称为”非聚簇索引“。

**InnoDB： **其数据文件本身就是索引文件。InnoDB表数据文件本身就是主索引。这被称为“聚簇索引”。而其余的索引都作为辅助索引。在根据主索引搜索时，直接找到key所在的结点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，在走一遍主索引。

```
1.为什么要给表加上主键？
	主键的作用就是把表的数据格式转换成索引（平衡树）的格式存放。
2.为什么加上主键后表查询的数据变快了？
	因为加上主键后，表的数据格式转换成B+Tree的结构，整个表变成了一个索引，通过索引可以快速的找到值，但是更新数据时速度将会降低。
3.什么情况下要同时在两个字段上建立索引？
	需要通过主键ID值的查找数据行的真实所在， 直接取得叶节点中user_name的值返回即可。 通过这种覆盖索引直接查找的方式， 可以省略不使用覆盖索引查找的后面两个步骤， 大大的提高了查询性能
```

### 4.1.4 什么是事务？

事务是逻辑上的一组操作，要么都执行，要么都不执行。

### 4.1.5 事务的四大特性（ACID）

**原子性**：事务要么全部完成，要么全部都不完成。

**一致性**：执行事务前，数据保持一致，多个事务对同一个数据读取的结果是相同的。

**隔离性**：并发访问数据库时，一个用户的事务不被其他事务所干扰。

**持久性**：一个事务被提交后，它对数据库中的数据的改变是持久的，即时数据库发生故障也不应该对其有任何影响。

### 4.1.6 并发事务会带来哪些问题？

**读未提交（脏读）**：当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问到了这个数据，然后使用了这个数据。因为这个数据是还未提交的，那么另一个事务读到的数据就是“脏数据”。

**丢失更新**：指一个事务读取一个数据时，另一个事务也读取了这个数据，那么在第一个事务中修改该数据，第二个事务也修改了这个数据，这样第一个事务内的修改结果就被丢失，因此称为丢失更新。

**不可重复读**：指在一个事务内多次读同一个数据，在这个事务还没有结束时，另一个事务也访问了该数据，并对该数据进行了修改，那么在第一个事务的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。

**幻读**：幻读与不可重复度类似。它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据。在随后的查询中，第一个事务就会发现多了一些原来不存在的数据。

### 4.1.7 事务隔离级别有哪些？MySQL的默认隔离级别是？

SQL标准中定义了四个隔离级别：

**读未提交(READ-UNCOMMITTED)**： 最低的隔离级别，允许读取未提交的数据，可能会导致**脏读、不可重复读、幻读**。

**读已提交(READ-COMMITTED)**：允许事务读取已提交的数据，**可以阻止脏读，但是幻读，不可重复度仍与可能发生。**

**可重复读(REPEATABLE-READ)：** 对同一字段的多次读取结果都是一致的，除非数据是被事务本身自己修改，**可以防止脏读，不可重复读，但是还是不能防止幻读。**

**可串行化(SERIALIZABLE)：** 最高的隔离级别，所有的事务依次执行，这样事务之间就完全不可能产生干扰，**可以防止脏读，不可重复读，幻读**。

| 隔离级别 |        脏读        |     不可重复读     |        幻读         |
| :------: | :----------------: | :----------------: | :-----------------: |
| 读未提交 | :heavy_check_mark: | :heavy_check_mark: | ::heavy_check_mark: |
| 读已提交 |        :x:         | :heavy_check_mark: | :heavy_check_mark:  |
| 可重复读 |        :x:         |        :x:         | :heavy_check_mark:  |
| 可串行化 |        :x:         |        :x:         |         :x:         |

MySQL中InnoDB引擎默认支持的隔离级别是REPEATABLE-READ(可重复读)，不同的是InnoDB在REPEATABLE-READ级别才用到是Next-Key Lock锁算法，因此可以避免幻读的产生，达到了SERIALIZABLE隔离程度，因为隔离事务级别越低，事务请求的锁越少所以大部分数据库采用COMMITTED-READ，但是InnoDB引擎默认使用的REPEATABLE-READ并不会有任何性能损失。

### 4.1.8 锁机制和InnoDB锁算法

MyISAM和InnoDB存储引擎使用的锁：

- MyISAM使用的是表级锁
- InnoDB支持行级锁和表级锁，默认使用行级锁

表级锁和行级锁对比：

- 表级锁：MySQL中锁定**粒度最大**的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概念最高，并发度最低。
- 行级锁：MySQL中锁定**粒度最小**的一种锁，只针对当前操作的行进行加锁。行级锁能大大降低锁冲突的概率，并发度高，但是加锁的开销也最大，加锁慢，会出现死锁。

### 4.1.9 大表优化

1. 限定数据范围

   查询数据时添加查询范围

2. 读/写分离

   主库负责写，从库负责读

3. 垂直分区

   把一张列比较多的表分成多张表

4. 水平分区

   保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。

### 4.1.10 解释一下什么是池化思想。什么是数据库连接池？为什么需要数据库连接池？

池化思想：这种设计会初始预设资源，解决的问题就是抵消每次获取资源的消耗，如创建线程的开销，获取远程连接的开销等。

数据库连接池：数据库连接池可以看做是维护数据库连接的缓存，以便于将来需要对数据库请求时可以常用这些连接。

为什么需要：在连接池中创建连接后，将其放置在池中，并再次使用它，因此不必创建新的连接，如果使用了所有连接，则会创建一个新连接并将其添加到池中。

### 4.1.11 分库分表之后，主键如何处理

生成全局唯一ID:

- **UUID：** 不适合当主键，太长，无序不可读，查询效率低，适合生成唯一的名字表示。
- **数据库自增id：** 两台数据库使用不同的步长，生成不重复的ID。这种方式生成的ID有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。
- **利用redis生成id：** 性能比较好，不依赖于数据库。但是引入了新的组件造成系统更加复杂，可用性降低，编码更复杂，增加了系统成本。
- **Twitter的snowflake算法**
- **美团的Leaf分布式ID生成系统**



Redis生成唯一主键：Redis Incr 命令将 key 中储存的数字值增一。如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCR 操作。如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。本操作的值限制在 64 位(bit)有符号数字表示之内。